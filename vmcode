code:
    inpv [value]
    2 byte
    000 + [value](12 bit) + extend_or_not(1 bit)
        - Set the value of register $V to 'value'
        - value: -2048 ~ 2047
        - value can be extended

    copy $[a] $[b]
    2 byte
    001 + [register a](3 bit) + [register b](3 bit) + 0_or_1(7 bit)
        - Copy the value of 'a' to 'b'
        - Not extendable

    jump $[a] $[b]
    1 byte
    010 + [register a](3 bit) + 0_or_1(2 bit)
        - if $[b] is True, jump to address 'a'
        - Not extendable

    comp $[a] [C-code] $[b]
    2 byte
    011 + [register a](3 bit) + [jump code](3 bit) + [register b](3 bit) + 0_or_1(4 bit)
        - Store the result of C-code comparison into $C
        - C-code:
            000 nv Never
            001 >  $[a] >  $[b]
            010 == $[a] == $[b]
            011 >= $[a] >= $[b]
            100 <  $[a] <  $[b]
            101 != $[a] != $[b]
            110 <= $[a] <= $[b]
            111 aw Always

    [operation]r $[a] $[b] $[c]
    2 byte
    100 [operation](3 bit) + [register a](3 bit) + [register b](3 bit) + [register c](3 bit) + 0_or_1(1 bit)
        - Operate $[a] and $[b] and save to $[c]
        - operation:
            000 add
            001 sub
            010 mul
            011 div
            100 rmv  # right move
            101 lmv  # left move
            110 and
            111 or_
        - Not extendable

    exte [value]
    2 byte
    101 + [value](15 bit) + extend_or_not(1 bit)
        - if extend_or_not == 1, [extendable value] = [extendable value] + value
        - value can be extended

    sett [0~7]
    1 byte
    110 + [0~7](3 bit) + 0_or_1(2 bit)
        - Set which of the 8 sub-registers in $T to use

register:
    $A: Address   000
    $C: Condition 001
    $D: Data      010
    $L: Local     011
    $M: Memory    100
    $P: Pointer   101
    $T: Temporary 110
    $V: Value     111

    # $A, $C, and $V are reserved for instruction-specific operations and should not be set manually.
    # Store results of conditional operations in $C for subsequent branching logic.
    # $T consists of 8 sub-registers (N0 to N7). Use the `setn` instruction to select the active sub-register.
    # $M represents memory. The specific address in memory is determined by the value in $A.
    # $D, $L, and $P are available as general-purpose registers.
    # suggestion:
        # $L local base address
        # $P stack top

    $[register]
        - Operate value of [register]

    @[register]
        - Operate address pointed to by [register]

syntactic sugar:
    setv $[a] [value]
        inpv [value]
        copy $V $[a]

    j-if $[a] $[b] [C-code] $[c]
        comp $[b] [C-code] $[c]
        jump $[a] $C

    load @[a] $[b]
        - equal: copy @[a] $[b]
        copy $[a] $A
        copy $M $[b]

    stor @[a] $[b]
        - equal: copy $[b] @[a]
        copy $[a] $A
        copy $[b] $M

    [operation]v $[a] [value] $[c]
        inpv [value]
        [operation] $[a] $V $[c]

    setl "[label]"
        - set label

    getl $[a] "[label]"
        - [value] = address of [label]
        setv $[a] [value]

    # The setl and getl instructions are pseudo-instructions managed by the assembler.

non-standard syntactic sugar:
    # Uses "general-purpose registers" and is therefore marked as "non-standard"

    push @[a] [value]
        sett 1
        addv $[a] [value] $T
        load @T $D
        sett 0
        stor @P $D
        addv $P 1 $P

    push @[a]
        load @[a] $D
        stor @P $D
        addv $P 1 $P
    
    push $[a]
        stor @P $[a]
        addv $P 1 $P

    pop @[a] [value]
        subv $P 1 $P
        load @P $D
        sett 1
        addv $[a] [value] $T
        stor @T $D
        sett 0

    pop @[a]
        subv $P 1 $P
        load @P $D
        stor @[a] $D
    
    pop $[a]
        subv $P 1 $P
        load @P $D
        copy $[a] $D

    alloc [value]
        - Allocate space of size [value] from haep and return the base address
        - return the base address: Push address to the location pointed to by $P

    call [function name] [number of argument]
        - jump to the location pointed to by [function name]
        - read argument from $P and $P -= [number of argument]

    return
        - jump to previous position
        - Push return-value to the location pointed to by $P
